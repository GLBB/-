# 垃圾收集器自动调整

> jvm 自己有一个选择策略，会选择合适的垃圾收集器，合适的堆大小及运行时编译策略，来满足不同应用的需要。

## 垃圾收集器，堆，运行时编译的默认选择策略

jvm 定义的服务器配置是：

* 两个处理器以上
* 物理内存超过 GB

jvm 给服务器的默认配置是：

* 选择 G1 垃圾收集器
* 初始化的堆大小为物理内存的1/64。
* 堆最大大小为物理内存的1/4。
* 分层使用编译器，同时使用C1和C2。

（C1 和 C2 参考：https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html）

## 基于行为的调优

我们通常会给 jvm 设置两个目标，一个是最大停顿时间，另一个是应用吞吐量，jvm 通常会尽量首先满足其中一个目标，然后最大会的满足另外一个目标。

### 最大停顿时间

最大停顿时间：垃圾收集器停止应用用来回收不在使用的空间所花费的时间。

垃圾收集器保存有垃圾收集的平均时间和平均时间的方差，如果平均时间+平均时间方差> 最大停顿时间， jvm 就认为这个目标没有满足。

最大停顿时间可以通过参数： `-XX:MaxGCPauseMillis=`<nnn>  来设置。

<nnn> 的单位是毫秒。 垃圾收集器会根据这个参数来调整堆的大小和其他的参数，来尽量满足 `XX:MaxGCPauseMillis` 这个参数设置的值。这个参数的默认值是和垃圾收集器相关的，不同的垃圾收集器默认值不同。

这个参数的调整可能会导致GC发生更加频繁，减少总体的吞吐量。

在某些情况下，设置了这个参数，也不会得到满足。

### 吞吐量

Q：如何衡量吞吐量？

吞吐量 = GC 时间/ (应用运行时间 - GC时间)

这个目标通过参数：`-XX:GCTimeRatio=`nnn  来指定吞吐量。

例子： -XX:GCTimeRatio=19

意味者吞吐量=1/(1+ 19)= 1/20=5%

即5%的时间可用于垃圾收集。

如果这个目标得不到满足，垃圾收集器可能会增大堆的大小，以便尽量减少GC次数。

### 最大停顿时间和吞吐量

如果最大停顿时间和吞吐量的满足了，jvm 会缩小堆的大小，直到其中一个目标不满足（通常是吞吐量首先不满足）。jvm 可以设置堆的最小值`-Xms=`<nnn> 。 设置堆的最大值：`-Xmx=`<mmm> 

## 调优策略

* 堆会增大或缩小来瞒住吞吐量目标，学习堆的调整策略，然后设置堆的最大值和最小值。
* 不要设置堆的最大值，除非你设置的最大值比默认的最大堆的值大，最好设置 `-XX:GCTimeRatio=` 这个参数来满足你的目标
* 应用行为也会导致堆的增大或缩小。 例如：应用分配堆空间频率很高时，堆会增大，来满足吞吐量目标。
* 如果堆增大到最大值，吞吐量目标还是不能满足，为了解决这个问题，可以设置堆的最大值接近物理内存的值，同时，不要让应用占用的内存交换到虚拟内存。
* 如果吞吐量目标满足了，但是停顿时间太长了，可以设置 `-XX:MaxGCPauseMillis=` ，设置这个参数后可能会导致吞吐量目标不能满足，因此需要给该参数设置一个合适的值。
* 因为吞吐量和最大停顿时间这两个冲突的目标，即使应用已经运行稳定了，堆的大小也可能会振荡。吞吐量总是期望一个大堆，停顿时间期望一个小堆。

