# 4. Schema 与数据类型优化

三个原则：

1. 更小的更好：选择能正确存储的最小数据类型。

   优点：占用更少的磁盘，内存，CPU缓存，CPU 周期也更少。

2. 简单更好：简单的数据类型需要更少的CPU 占用周期。整数 < 字符串，字符串需要字符集和校对规则。

   举例：使用 mysql 内置的 date 类型存储时间，而不是字符串。

   ​           使用整数存储 ip 地址，而不是使用字符串。

3. 尽量避免 null

   null 是列的默认值，如果列不需要 null 值，最好设置为 not null。可为 null 的列会使索引，索引统计，值都更加复杂。可为 null 的列也会占用更多的存储空间，被索引时，每个索引记录都需要一个额外的字节，在 MyISAM 中，可能会导致定长的索引变为变长的索引。

   把可为 null 的列改为 not null 带来的性能可能比较小，但在设计时，最好将不为 null 的列设置为 not null。

   InnoDB 使用单独的位来存储 null 值，对于稀疏数据有比较好的效率。

## 选择优化的数据类型

### 整数类型

整数数据类型：tinyint, smallint, mediumint, int, bigint。分别用 1, 2, 3, 4, 8 个字节存储。

整数类型可以设置为 unsigned, 表示无符号数。

mysql 可以为整数指定宽度, 如 int(11), 对大多数应用没有意义，规定了交互工具显示的字符数。

### 实数类型

不精确的浮点类型：float, double.

精确的小数类型: decimal。CPU 不支持 decimal 的运算，mysql 服务器自生实现了 decimal 的高进度计算，当然浮点数的计算会更快一点。

浮点类型和 decimal 都可以指定精度，decimal 可以指定小数点后的位数，decimal 使用二进制字符串存储数据，4个字节存储 9 为数字，如 decimal(18, 9) 需要占用 9 个字节，小数点前面最多 9 个数字，后面 9 位小数，在加一个字节存储小数点。

decimal 最多只能存储 65位数字。

因为 decimal 带来的计算和存储开销，想要精确计算，还能用 bigint 来代替 decimal, 将小数点乘以相应的倍数，避免 浮点数带来的不精确性和 decimal 计算的开销。

### 字符串类型

**varchar 和 char 类型**

varchar 类型用于变长字符串。但要注意创建表时是否使用 row_formate = fixed, 如果使用了该属性，那么 varchar 也会变成定长的。

varchar 使用额外的 1或 2个 字节存储字符串的长度，如果列的最大长度小于等于 255 字节，就只需要一个字节表示字符串长度，否则就需要两个字节。latin1 编码下，varchar(10) 需要11个字节的存储空间。

varchar 也会带来一些影响，行占用的空间增长，或许会导致页分裂等问题。

varchar 适用场景：最长长度比平均长度长很多；列的更新很少，碎片不是问题；使用了 UTF-8 这样的复杂字符集。

varchar 可以保留字符串末尾的空格。

char 类型: 定长，不保留末尾的空格。

使用场景：存储短字符串或所有字符串长度接近，对于经常变更的数据，定长的 char 更不容易产生碎片。

varchar(5) 和 varchar(200) 的区别: 存储 'hello' 字符串的长度是相同的，但是 varchar(200) 会消耗更多的内存空间，因为 mysql 会分配固定大小的内存块来保存内部值。

**text 和 blob 类型**

目的是存储很大的数据的字符串数据类型，分别采用字符和二进制的方式存储。

字符类型有： tinytext, smalltext, text, mediumtext, longtext.

二进制类型：tinyblob, smallblob, blob, mediumblob, longblob.

mysql 会将 text 和 blob 的值作为独立的对象来存储，当 text 和 blob 的值太大时， 在行内存储 1-4字节的指针，指向实际存储的值。

对 text, blob 类型的字段进行排序时，只对列最前面 max_sort_length 字节排序，当然也可以使用函数 sustring(column, length) 进行排序。

mysql 不能对全部长度的 text, blob 进行索引，也不能消除排序。

**使用 enum 代替字符串类型**

mysql 会将 enum 值存储为整数值，在表 .frm 文件中存储 数字--字符串映射关系。

查看 enum 值对应的整数值：

> select enum_cols + 0 from enum_table

enum 排序是根据内部的整数的大小进行排序。

注意不要将枚举值设为数据，容易造成混淆。

想要对 enum 进行指定顺序排序，可以使用 field 函数。

枚举值字符串列表是固定的，如果改变枚举列表需要重建整个表，但是可以只在列表末尾添加元素，可以不重建整个表。

同时因为 enum 是整数值存储，所以 enum 和 enum join 时也比 varchar 和 varchar 类型 join 快。

### 日期和时间类型

datetime 和 timestamp:

datetime ：能保存 1001 ~ 9999 年，精度为秒，将时间封装到 YYYYMMDDHHMMSS 的整数值中，和时区无关，使用 8字节的存储空间。

timestamp: 保存从 1970 年 1 月 1 日午夜到时间的秒数，使用四个字节存储空间。只能表示 1970 年 ~ 2038 年，有函数 from_unixtime 将 Unix 时间戳转换为 日期，unix_timestamp 将日期转换为时间戳。

timestamp 显示的值依赖 时区，mysql 服务器，操作系统，客户端的连接 都有时区设置。

当类型为 timestamp 的第一个列插入值时，插入 null 会默认显示当前时间，timestamp 默认 not null。

### 位数据类型

 bit: bit(1) 定义一个位， bit(2) 定义两个位，MyISAM 会打包所有的 bit 类型，如 17 个单独的 bit 列占用 3 个字节，但 Innodb 和 memory 为每个 bit 列创建一个最小的整数，不能节省空间。

mysql 将 bit 当作字符串类型，而不是数字类型。当检索二进制位时，是 ‘0’ 或 '1' 的字符串，在数字上下文场景中，会转化为数字。

如果表示多个 bit， 可以使用整数来模拟，

### 选择标识符

整数类型比较好，

enum 和 set 是比较糟糕的选择。

注意使用字符串类型的标识符，使用 uuid 生成，会导致随机插入，页分裂，磁盘随机访问，以及聚簇索引产生的碎片问题。同时 select 也更慢，逻辑上相邻的列会分散在磁盘和内存的不同地方。

## Schema 设计中的陷阱

太多的列：什么叫多？数千个字段。

太多的关联：最多只能关联 61 个，同时又存在许多自关联，如果希望查询执行得快速且并发性好，单个查询最好在12表以内做关联。

防止过度使用枚举。

隐式使用枚举：有时不注意使用集合替代了枚举。

不要害怕使用 null。

## 范式和反范式

**范式优点**

* 更新操作更快
* 需要修改更少的数据
* 范式化得表通常比较小，容易存储在内存中。
* 更少需要使用 distinct, group by

**范式缺点**

* 复杂得查询需要多次关联
* 使索引策略无效

**反范式优点**

* 避免关联
* 当数据比较大时，避免随机 IO
* 使用更有效得索引策略

### 范式与范式结合

反范式可以使用触发器解决冗余数据问题。

